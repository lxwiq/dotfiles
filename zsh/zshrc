# Path to your Oh My Zsh installation.
export ZSH="$HOME/.oh-my-zsh"

# Disable Oh My Zsh theme (we'll use Oh My Posh instead)
ZSH_THEME=""

# Enable plugins
plugins=(
  git                     # Git integration and aliases
  z                       # Jump to directories based on frequency
  zsh-autosuggestions     # Fish-like autosuggestions
  zsh-syntax-highlighting # Syntax highlighting for commands
  fzf                     # Fuzzy finder integration
  colored-man-pages       # Colorized man pages
  command-not-found       # Suggests package to install if command not found
  copypath                # Copy current directory path to clipboard
  copyfile                # Copy file contents to clipboard
  dirhistory              # Keyboard shortcuts for directory history navigation
  extract                 # Extract any archive with 'x' command
  history                 # History aliases and functions
  sudo                    # Press ESC twice to add sudo to current command
  web-search              # Search from terminal (e.g., google, duckduckgo)
  jsontools               # Tools for working with JSON (e.g., pp_json, is_json)
  docker                  # Docker aliases and functions
  docker-compose          # Docker Compose aliases

  # Front-end development
  npm                     # NPM aliases and completion
  nvm                     # NVM (Node Version Manager) integration
  node                    # Node.js aliases and functions
  yarn                    # Yarn package manager support
  ng                      # Angular CLI completion and aliases
  vscode                  # VS Code integration

  # Backend development
  python                  # Python aliases and functions
  pip                     # Pip completion and aliases
  golang                  # Go language support
  rust                    # Rust language support

  # Utilities
  tmux                    # Tmux aliases and functions
  httpie                  # HTTPie aliases (REST client)
  dotenv                  # Automatically load .env files
  gh                      # GitHub CLI integration
)

# Source Oh My Zsh
source $ZSH/oh-my-zsh.sh

# Configuration de Starship - un prompt moderne, rapide et hautement personnalisable
# Assurez-vous que le répertoire de configuration existe
if [ ! -d "$HOME/.config" ]; then
    mkdir -p "$HOME/.config"
fi

# Initialiser Starship
eval "$(starship init zsh)"

# Configuration de l'historique
HISTSIZE=10000
SAVEHIST=10000
HISTFILE=~/.zsh_history
setopt EXTENDED_HISTORY
setopt SHARE_HISTORY
setopt HIST_IGNORE_DUPS
setopt HIST_FIND_NO_DUPS
setopt HIST_REDUCE_BLANKS

# Activer la complétion
autoload -Uz compinit && compinit

# Configuration de la complétion pour qu'elle ressemble à MenuComplete de PowerShell
zstyle ':completion:*' menu select
zstyle ':completion:*' matcher-list 'm:{a-zA-Z}={A-Za-z}'

# Fix color issues with completion - simplified approach
export CLICOLOR=1
export LSCOLORS=ExGxBxDxCxEgEdxbxgxcxd
zstyle ':completion:*' list-colors ''

zstyle ':completion:*' group-name ''
zstyle ':completion:*:descriptions' format '%F{green}-- %d --%f'
zstyle ':completion:*:messages' format '%F{yellow}-- %d --%f'
zstyle ':completion:*:warnings' format '%F{red}-- Pas de correspondance --%f'
zstyle ':completion:*:corrections' format '%F{yellow}-- %d (erreurs: %e) --%f'
zstyle ':completion:*' verbose yes
zstyle ':completion:*' use-cache on
zstyle ':completion:*' cache-path ~/.zsh/cache

# Raccourcis clavier (équivalents à ceux de PowerShell)
bindkey '^d' delete-char
bindkey '^[[A' history-beginning-search-backward
bindkey '^[[B' history-beginning-search-forward
bindkey '^I' menu-complete  # Tab pour la complétion de menu, comme dans PowerShell

# Configuration de fzf (équivalent à PSFzf)
if command -v fzf &> /dev/null; then
    export FZF_DEFAULT_OPTS="--height 40% --layout=reverse --border"

    # Charger l'intégration fzf
    [ -f ~/.fzf.zsh ] && source ~/.fzf.zsh

    # Configurer Ctrl+R pour rechercher dans l'historique avec fzf (comme dans PowerShell)
    bindkey '^r' fzf-history-widget

    # Configurer Ctrl+F pour rechercher des fichiers avec fzf (comme dans PowerShell)
    bindkey '^f' fzf-file-widget
fi

# Configuration de lsd (équivalent à Terminal-Icons)
if command -v lsd &> /dev/null; then
    # Remplacer ls par lsd pour avoir des icônes
    alias ls='lsd'
    alias l='lsd -l'
    alias la='lsd -la'
    alias lt='lsd --tree'
    alias ll='lsd -la'
    alias lsd='lsd -la'
else
    # Fallback si lsd n'est pas installé
    alias ll='ls -la'
    alias la='ls -la'
    alias l='ls -l'
fi

# Définir des alias (équivalents à ceux de PowerShell)

# Éditeur
alias vim='nvim'
alias vi='nvim'
alias v='nvim'

# Navigation
alias ..='cd ..'
alias ...='cd ../..'
alias ....='cd ../../..'
alias .....='cd ../../../..'
alias ~='cd ~'
alias -- -='cd -'
alias cd.='cd ..'
alias oe='open .'
alias o='open'

# Lister les fichiers
# Use GNU ls on macOS if available, otherwise use standard ls with appropriate flags
if command -v gls &> /dev/null; then
    alias ls='gls --color=auto'
else
    alias ls='ls -G'
fi
alias grep='grep --color=auto'
alias fgrep='fgrep --color=auto'
alias egrep='egrep --color=auto'
alias du='du -h'
alias df='df -h'
alias free='free -m'

# Utilitaires système
alias top='htop 2>/dev/null || top'
alias h='history'
alias j='jobs -l'
alias path='echo -e ${PATH//:/\\n}'
alias now='date +"%T"'
alias nowtime=now
alias nowdate='date +"%d-%m-%Y"'
alias ports='netstat -tulanp'
alias meminfo='free -m -l -t'
alias psmem='ps auxf | sort -nr -k 4'
alias pscpu='ps auxf | sort -nr -k 3'

# Git
alias g='git'
alias gs='git status'
alias ga='git add'
alias gc='git commit -m'
alias gp='git push'
alias gl='git pull'
alias gd='git diff'
alias gco='git checkout'
alias gb='git branch'
alias glog='git log --oneline --decorate --graph'

# Docker
alias d='docker'
alias dc='docker-compose'
alias dps='docker ps'
alias dimg='docker images'

# Angular
alias ng='ng'
alias ngs='ng serve'
alias ngt='ng test'
alias ngb='ng build'
alias ngg='ng generate'
alias ngl='ng lint'
alias ngc='ng component'
alias ngsw='ng serve --open'
alias ngbp='ng build --prod'

# Svelte
alias svdev='npm run dev'
alias svbuild='npm run build'
alias svstart='npm run start'

# Node.js & NPM
alias ni='npm install'
alias nid='npm install --save-dev'
alias nig='npm install -g'
alias ns='npm start'
alias nt='npm test'
alias nb='npm run build'
alias nr='npm run'
alias ncu='npx npm-check-updates'
alias ncuu='npx npm-check-updates -u'

# Yarn
alias y='yarn'
alias ya='yarn add'
alias yad='yarn add --dev'
alias yag='yarn global add'
alias ys='yarn start'
alias yt='yarn test'
alias yb='yarn build'

# Rust
alias cr='cargo run'
alias cb='cargo build'
alias ct='cargo test'
alias cc='cargo check'
alias crr='cargo run --release'
alias cbr='cargo build --release'
alias cw='cargo watch'
alias cf='cargo fmt'
alias ccl='cargo clippy'
alias cn='cargo new'

# Go
alias gr='go run'
alias gb='go build'
alias gt='go test'
alias gf='go fmt'
alias gi='go install'
alias gim='go mod init'
alias gtd='go mod tidy'
alias gv='go vet'

# Tmux
alias t='tmux'
alias ta='tmux attach -t'
alias tls='tmux list-sessions'
alias tn='tmux new -s'

# Raccourcis divers
alias c='clear'
alias cls='clear'
alias e='exit'
alias r='reload'
alias sz='source ~/.zshrc'
alias ez='$EDITOR ~/.zshrc'
alias et='$EDITOR ~/.config/tmux/tmux.conf'
alias ip='get_pub_ip'
alias localip='ipconfig getifaddr en0'
alias myip='curl -s http://ipecho.net/plain; echo'
alias weather='curl -s wttr.in'
alias cpwd='pwd | tr -d "\n" | pbcopy'
alias ping='ping -c 5'
alias www='python -m SimpleHTTPServer 8000'
alias speedtest='curl -s https://raw.githubusercontent.com/sivel/speedtest-cli/master/speedtest.py | python -'

# Sécurité
alias rm='rm -i'
alias cp='cp -i'
alias mv='mv -i'
alias ln='ln -i'

# Fonction pour créer un répertoire et y accéder (équivalent à mkcd)
mkcd() {
    mkdir -p "$1" && cd "$1"
}

# Fonction pour obtenir l'adresse IP publique (équivalent à Get-PubIP)
get_pub_ip() {
    curl -s http://ifconfig.me/ip
}

# Fonction pour mettre à jour les paquets (équivalent à Update)
update() {
    if command -v brew &> /dev/null; then
        echo "Mise à jour de Homebrew..."
        brew update && brew upgrade
    fi
}
alias u='update'

# Fonction pour recharger le profil zsh (équivalent à Update-Profile)
reload() {
    source ~/.zshrc
}

# Fonction pour trouver des fichiers par nom (équivalent à Find-File)
ff() {
    find . -name "*$1*" -type f
}

# Fonction pour créer une sauvegarde d'un fichier (équivalent à Backup-File)
bak() {
    cp "$1" "$1.bak"
}

# Fonction pour créer un nouveau fichier (équivalent à New-File)
nf() {
    touch "$1"
}

# Fonction pour rechercher dans l'historique (équivalent à Search-History)
sh() {
    history | grep "$1"
}

# Fonction pour extraire n'importe quel type d'archive
extract() {
    if [ -f $1 ] ; then
        case $1 in
            *.tar.bz2)   tar xjf $1     ;;
            *.tar.gz)    tar xzf $1     ;;
            *.bz2)       bunzip2 $1     ;;
            *.rar)       unrar e $1     ;;
            *.gz)        gunzip $1      ;;
            *.tar)       tar xf $1      ;;
            *.tbz2)      tar xjf $1     ;;
            *.tgz)       tar xzf $1     ;;
            *.zip)       unzip $1       ;;
            *.Z)         uncompress $1  ;;
            *.7z)        7z x $1        ;;
            *)           echo "'$1' cannot be extracted via extract()" ;;
        esac
    else
        echo "'$1' is not a valid file"
    fi
}

# Fonction pour créer une archive
compress() {
    if [ -n "$1" ] ; then
        FILE=$1
        case $FILE in
            *.tar.bz2)  shift && tar cjf $FILE $* ;;
            *.tar.gz)   shift && tar czf $FILE $* ;;
            *.tar)      shift && tar cf $FILE $*  ;;
            *.zip)      shift && zip -r $FILE $*  ;;
            *.7z)       shift && 7z a $FILE $*   ;;
            *)          echo "'$FILE' cannot be compressed via compress()" ;;
        esac
    else
        echo "usage: compress <file.tar.gz> [files]"
    fi
}

# Fonction pour créer rapidement un serveur HTTP
server() {
    local port="${1:-8000}"
    open "http://localhost:${port}/"
    python -m SimpleHTTPServer "$port"
}

# Fonction pour afficher les couleurs du terminal
colors() {
    for i in {0..255}; do
        printf "\x1b[38;5;${i}mcolor%-5i\x1b[0m" $i
        if ! (( ($i + 1 ) % 8 )); then
            echo
        fi
    done
}

# Fonction pour calculer
calc() {
    echo "scale=2; $*" | bc
}

# Fonction pour créer un répertoire et y aller
take() {
    mkdir -p $1
    cd $1
}

# Fonction pour trouver des fichiers contenant un texte
find_text() {
    grep -r "$1" .
}

# Fonction pour afficher l'arborescence des répertoires
tree_dir() {
    find . -type d -print | sed -e 's;[^/]*/;|____;g;s;____|; |;g'
}

# Fonction pour afficher les processus utilisant un port
port_usage() {
    lsof -i :"$1"
}

# Fonction pour tuer un processus utilisant un port
kill_port() {
    kill -9 $(lsof -t -i:"$1")
}

# Fonction pour obtenir la météo
weather_full() {
    curl -s "wttr.in/$1"
}

# Fonction pour générer un mot de passe aléatoire
genpass() {
    local length="${1:-16}"
    LC_ALL=C tr -dc 'A-Za-z0-9_!@#$%^&*()' < /dev/urandom | head -c $length | xargs
}

# Fonction pour convertir une vidéo en GIF
video2gif() {
    ffmpeg -i "$1" -vf "fps=10,scale=320:-1:flags=lanczos" -c:v pam -f image2pipe - | convert -delay 10 - -loop 0 -layers optimize "$2"
}

# Fonction pour obtenir l'IP d'un domaine
getip() {
    dig +short "$1"
}

# Fonction pour vérifier si un site est accessible
checksite() {
    curl -s --head "$1" | head -n 1
}

# Fonction pour nettoyer les fichiers .DS_Store
cleanDS() {
    find . -type f -name '*.DS_Store' -ls -delete
}

# ===== Fonctions pour le développement front-end =====

# Créer un nouveau projet Angular
ng-new() {
    ng new "$1" --routing --style=scss "${@:2}"
}

# Créer un nouveau projet Svelte avec SvelteKit
svelte-new() {
    npm create svelte@latest "$1"
    cd "$1" || return
    npm install
    echo "Projet Svelte créé dans $1"
}

# Analyser la taille du bundle
bundle-analyze() {
    if [ -f "package.json" ]; then
        npx source-map-explorer dist/**/*.js
    else
        echo "Aucun fichier package.json trouvé dans le répertoire courant"
    fi
}

# Lancer un serveur de développement avec live-server
live() {
    local port="${1:-8080}"
    npx live-server --port="$port"
}

# Optimiser les images dans un répertoire
optimize-images() {
    local dir="${1:-.}"
    find "$dir" -type f \( -name "*.jpg" -o -name "*.jpeg" -o -name "*.png" \) -exec npx imagemin {} --out-dir="$dir/optimized" \;
    echo "Images optimisées dans $dir/optimized"
}

# Générer des favicons à partir d'une image
gen-favicons() {
    if [ -z "$1" ]; then
        echo "Usage: gen-favicons <image-source>"
        return 1
    fi
    npx real-favicon generate favicon-config.json favicon-data favicon
    echo "Favicons générés dans le répertoire favicon"
}

# ===== Fonctions pour Rust =====

# Créer et exécuter un nouveau projet Rust
rust-new() {
    cargo new "$1"
    cd "$1" || return
    cargo run
}

# Exécuter un benchmark Rust
rust-bench() {
    cargo bench
}

# Analyser la taille du binaire Rust
rust-size() {
    cargo build --release
    ls -lh target/release
}

# Vérifier la sécurité des dépendances Rust
rust-audit() {
    cargo audit
}

# ===== Fonctions pour Go =====

# Créer un nouveau projet Go
go-new() {
    local project_name="$1"
    local module_path="${2:-github.com/$(whoami)/$1}"

    mkdir -p "$project_name"/cmd/"$project_name"
    mkdir -p "$project_name"/internal
    mkdir -p "$project_name"/pkg

    cd "$project_name" || return
    go mod init "$module_path"

    # Créer un fichier main.go de base
    cat > cmd/"$project_name"/main.go << EOF
package main

import (
	"fmt"
)

func main() {
	fmt.Println("Hello, $project_name!")
}
EOF

    # Créer un fichier README.md de base
    cat > README.md << EOF
# $project_name

Description de votre projet.

## Installation

\`\`\`bash
go get $module_path
\`\`\`

## Utilisation

\`\`\`bash
go run cmd/$project_name/main.go
\`\`\`
EOF

    echo "Projet Go créé dans $project_name avec la structure standard"
}

# Exécuter tous les tests Go avec couverture
go-test-cover() {
    go test -cover ./...
}

# Générer un rapport de couverture HTML
go-cover-html() {
    go test -coverprofile=coverage.out ./...
    go tool cover -html=coverage.out
    rm coverage.out
}

# Linter Go avec golangci-lint
go-lint() {
    golangci-lint run ./...
}

# Activer les prédictions basées sur l'historique (comme PredictionSource = 'History' dans PowerShell)
if [[ -f ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-autosuggestions/zsh-autosuggestions.zsh ]]; then
    # Configurer les suggestions pour qu'elles ressemblent à PSReadLine
    ZSH_AUTOSUGGEST_STRATEGY=(history completion)
    ZSH_AUTOSUGGEST_HIGHLIGHT_STYLE="fg=#2F7004"  # Même couleur que dans PowerShell
    ZSH_AUTOSUGGEST_BUFFER_MAX_SIZE=20
    ZSH_AUTOSUGGEST_USE_ASYNC=1
    ZSH_AUTOSUGGEST_MANUAL_REBIND=1
fi

# Exporter les variables d'environnement nécessaires
export EDITOR='nvim'
export VISUAL='nvim'
export PAGER='less'
export LANG=en_US.UTF-8
export LC_ALL=en_US.UTF-8

# Conserver les configurations existantes
export NVM_DIR="$HOME/.nvm"
[ -s "/opt/homebrew/opt/nvm/nvm.sh" ] && \. "/opt/homebrew/opt/nvm/nvm.sh"  # This loads nvm
[ -s "/opt/homebrew/opt/nvm/etc/bash_completion.d/nvm" ] && \. "/opt/homebrew/opt/nvm/etc/bash_completion.d/nvm"  # This loads nvm bash_completion

# Load Angular CLI autocompletion.
if command -v ng &> /dev/null; then
    source <(ng completion script)
fi


# ===== Configurations supplémentaires =====

# Activer la correction automatique des commandes
setopt correct
setopt correctall

# Activer le changement de répertoire sans cd
setopt autocd

# Complétion améliorée
setopt always_to_end        # Placer le curseur à la fin de la ligne après complétion
setopt complete_in_word     # Compléter à partir de la position du curseur
setopt auto_menu            # Afficher le menu de complétion après la seconde tabulation
setopt auto_list            # Lister automatiquement les possibilités de complétion

# Historique amélioré
setopt append_history       # Ajouter à l'historique plutôt que de le remplacer
setopt inc_append_history   # Ajouter les commandes à l'historique au fur et à mesure
setopt hist_expire_dups_first # Supprimer les doublons en premier lors du nettoyage
setopt hist_ignore_space    # Ne pas enregistrer les commandes commençant par un espace

# Globbing et expansion
setopt extended_glob        # Utiliser le globbing étendu
setopt glob_dots            # Inclure les fichiers cachés dans le globbing

# Divers
setopt interactive_comments # Permettre les commentaires dans les commandes interactives
setopt no_beep              # Désactiver les bips
setopt prompt_subst         # Permettre la substitution dans les prompts

# Raccourcis clavier supplémentaires
bindkey '^L' clear-screen            # Ctrl+L - effacer l'écran (priorité élevée)
bindkey '^[[1;5C' forward-word       # Ctrl+Right - avancer d'un mot
bindkey '^[[1;5D' backward-word      # Ctrl+Left - reculer d'un mot
bindkey '^[[H' beginning-of-line     # Home - début de ligne
bindkey '^[[F' end-of-line           # End - fin de ligne
bindkey '^[[3~' delete-char          # Delete - supprimer caractère
bindkey '^H' backward-kill-word      # Ctrl+Backspace - supprimer mot précédent

# Assurer que Ctrl+L fonctionne toujours pour effacer l'écran
stty -ixon # Désactiver le contrôle de flux XON/XOFF pour libérer Ctrl+S et Ctrl+Q

# Activer la coloration syntaxique pour less
export LESS="-R"
export LESS_TERMCAP_mb=$'\E[1;31m'     # début de blink
export LESS_TERMCAP_md=$'\E[1;36m'     # début de bold
export LESS_TERMCAP_me=$'\E[0m'        # fin de mode
export LESS_TERMCAP_so=$'\E[01;44;33m' # début de standout-mode
export LESS_TERMCAP_se=$'\E[0m'        # fin de standout-mode
export LESS_TERMCAP_us=$'\E[1;32m'     # début de underline
export LESS_TERMCAP_ue=$'\E[0m'        # fin de underline

# Activer la complétion pour les commandes sudo
zstyle ':completion:*:sudo:*' command-path /usr/local/sbin /usr/local/bin /usr/sbin /usr/bin /sbin /bin

# Activer la complétion pour les hôtes SSH
zstyle ':completion:*:(ssh|scp|sftp):*' hosts $hosts
zstyle ':completion:*:(ssh|scp|sftp):*' users $users

# Activer la complétion pour les processus
zstyle ':completion:*:*:kill:*:processes' list-colors '=(#b) #([0-9]#) ([0-9a-z-]#)*=01;34=0=01'
zstyle ':completion:*:*:*:*:processes' command "ps -u $USER -o pid,user,comm -w -w"

# Configuration minimaliste - pas de message de bienvenue

# Oh My Posh gère automatiquement l'affichage de l'environnement virtuel Python

# Fonction pour créer et activer un environnement virtuel Python
venv() {
    local venv_name="${1:-.venv}"
    python -m venv "$venv_name"
    source "$venv_name/bin/activate"
    echo "\033[0;32mEnvironnement virtuel '$venv_name' créé et activé\033[0m"
}

# Alias pour activer rapidement un environnement virtuel
alias av='source .venv/bin/activate || source venv/bin/activate || echo "\033[0;31mAucun environnement virtuel trouvé (.venv ou venv)\033[0m"'
alias dv='deactivate'
